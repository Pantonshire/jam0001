//Horizontal whitespace
hws = _{ " " | "\t" }
//Vertical whitespace
vws = _{ hws* ~ NEWLINE ~ hws* }

//basic definitions
digit = { '0'..'9' }
alpha = { ('a'..'z'|'A'..'Z')+ }
number = { digit+ }
alphanumeric = { (alpha | number | "_" | "-")+ }
identAny = { alpha | alpha ~ alphanumeric }
ident = { !((^"then" | ^"as" | ^"storing") ~ (hws | NEWLINE | EOI)) ~ identAny }

stringContents = { (!("\"") ~ ANY)* }
string = { "\"" ~ stringContents ~ "\"" }

//expressions
opNeq = { "!=" }
opEq  = { "==" }
opGt  = { ">" }
opGe  = { ">=" }
opLt  = { "<" }
opLe  = { "<=" }
opSub = { "-" }
opAdd = { "+" }
opOr  = { ^"or" | "||" }
opDiv = { "/" }
opMul = { "*" }
opAnd = { ^"and" | "&&" }
opNot = { ^"not" | "!" }
opNeg = { "-" }

litTrue  = { ^"true" }
litFalse = { ^"false" }

expr        = { equality }
equality    = { comparison ~ (hws* ~ (opNeq | opEq) ~ hws* ~ comparison )* }
comparison  = { termOr ~ (hws* ~ (opGt | opGe | opLt | opLe) ~ hws* ~ termOr )* }
termOr      = { factorAnd ~ (hws* ~ (opSub | opAdd | opOr) ~ hws* ~ factorAnd )* }
factorAnd   = { unary ~ (hws* ~ (opDiv | opMul | opAnd) ~ hws* ~ unary)? }
unary       = { (opNot | opNeg) ~ hws* ~ unary | primary }
primary     = { number | litTrue | litFalse | ident | string | "(" ~ hws* ~ expr ~ hws* ~ ")" }

//statements
varStmt = { ^"stores" ~ hws+ ~ expr ~ hws+ ~ ^"in" ~ hws+ ~ ident }
loopStmt = { ^"repeatedly" ~ hws+ ~ "(" ~ hws* ~ comment ~ hws* ~ ")" ~ hws+ ~ expr ~ hws+ ~ ^"times" }
callStmt = { ident ~ (hws+ ~ callArgs)? ~ (("," | hws) ~ hws* ~ callStore)? }
callArgs = { expr ~ (hws* ~ "," ~ hws* ~ expr)* }
callStore = { ^"storing" ~ hws+ ~ ^"the" ~ hws+ ~ (^"output" | ^"result") ~ hws+ ~ ^"in" ~ hws+ ~ ident }
listStmt = { ident | ident ~ "," ~ listStmt }
argsStmt = { ^"takes" ~ hws+ ~ listStmt}
condStmt = { ^"if" ~ hws+ ~ expr ~ hws+ ~ ^"do" ~ hws+ ~ comment ~ hws+ ~ ^"else" ~ hws+ ~ comment}
consStmt = { ^"constant" ~ hws+ ~ ident ~ hws+ ~ ^"is" ~ hws+ ~ expr}
returnStmt = { (^"outputs" | ^"returns") ~ hws+ ~ expr }
stmt = { argsStmt | varStmt | loopStmt | condStmt | consStmt | returnStmt | callStmt }
comment = { stmt ~ ((hws | ",") ~ hws* ~ "then" ~ hws+ ~ stmt)* }
commentStmt = { "//" ~ hws* ~ (fnIntro ~ hws+)? ~ comment ~ vws+ ~ ^"function" ~ hws+ ~ ident ~ hws* ~ "(" ~ hws* ~ (ident ~ (hws* ~ "," ~ hws* ~ ident)*)? ~ hws* ~ ")" }
semanticBody = {commentStmt ~ (vws+ ~ semanticBody)*}
syntaxBody = {"\n" ~ ("\n"|" ")* ~ "main {" ~ (("\n")*~mainStmt~("\n")*)* ~ "}"}
mainStmt = { ident ~"<-"~ mainStmt | ident ~ "(" ~ mainStmt ~ ")" | ident }
program = { vws* ~ semanticBody ~ syntaxBody|semanticBody ~ vws* }

fnIntro = _{ (^"a" ~ hws+ ~ ^"function" ~ hws+ ~ ^"which") | (^"this" ~ hws+ ~ ^"function") }











